<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<STYLE TYPE="text/css">
		BODY {
			background-color: f5f5f5;
			font-family: verdana, arial; font-size: small;
		}
		H2, H3, A, .tfc {
			color: #000080;
			font-family: verdana, arial; font-size: small;
		}
		PRE { 
		    font-family: monospace;
		    border: 1px solid black;
		    white-space: pre; 
		    color: black;
		    background-color: #dfdfdf; 
		}
		TABLE {
			float: right;
			border-collapse: collapse;
			border-top: 1px solid #000000;
			border-right: 1px solid #000000;
			border-left: 1px solid #000000;
		}
		TH {
			padding-top: 2px;
			padding-bottom: 2px;
			padding-right: 5px;
			padding-left: 5px;
		}
		TD {
			padding-top: 2px;
			padding-bottom: 2px;
			padding-right: 5px;
			padding-left: 5px;
			border-bottom: 1px solid #000000;
			border-right: 1px solid #000000;
		}
	</STYLE>
<TITLE>Encdec</TITLE>
</HEAD>
<BODY>
<H2>1. Encdec</H2>
These functions may be used to encode and decode C objects such  as  integers, floats, doubles, times, and internationalized strings to and from a wide variety of binary formats as they might appear in portable file formats or network messages. These encodings include 16, 34, and 64 bit big and little endian intergers, big and little endian IEEE754 float and double values, 6 time encodings, and the wide range of string encodings supported by libiconv. The functions are all designed to be ideal for in-situ decoding and encoding of complex formats.
<p>
</p>
<b>The Encdec Java Class</b>
<p>
</p>
See the <tt>src/Encdec.java</tt> file for equivalent methods in Java. Formats generated by these two implementations are compatible with two exceptions; 64 bit times encdoded using Java will be truncated to the 1 second resolution of the C <tt>time_t</tt> type and the Java methods do not provide string encoding/decoding methods because Java supports a wide variety of encodings natively. The "UTF-8" encoding is good for transferring strings between Java and C. Note the encoding identifier used with the <tt>String</tt> constructor and <tt>String.getBytes()</tt> method may need to be specified as "UTF8" without the hyphen. In-fact many of the identifiers are different so it will be necessary to look up the correct identifier in the Java i18n documentation.
<H3>1.1. The FLD macro</H3>
<A name="The FLD macro"></A>
<P>
<B CLASS="tfc">The <TT>FLD</TT> macro</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
	
  unsigned int FLD(i, m);
  </PRE>
<B>Description</B>
<BR>
The <TT>FLD</TT> macro is used to decode bit-fields. It returns an integer value representing the value occupying the bits in mask <tt>m</tt>. If for example the input is <tt>0xCBA98765</tt> and the mask is <tt>0x00FFFF00</tt> a value of <tt>0xA987</tt> will be returned. With basic register optimizations this is equivalent to the expression (<tt>0xCBA98765 &gt;&gt; 8) &amp; 0xFFFF</tt>. Masks can be complex. The mask <tt>0x7F080</tt> is equivalent to <tt>(i &gt;&gt; 7) &amp; 0xFE1</tt>.
	<BR>
</P>
<H3>1.2. Integer functions</H3>These functions should be used to encode and decode 16, 32, and 64 bit integers.<A name="enc_uint16be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint16be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint16be(uint16_t s, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 16 bit integer in big endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 2.
	<BR>
<P>
</P>
<A name="enc_uint32be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint32be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint32be(uint32_t i, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 32 bit integer in big endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 4.
	<BR>
<P>
</P>
<A name="enc_uint64be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint64be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint64be(uint64_t l, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 64 bit integer in big endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 8.
	<BR>
<P>
</P>
<A name="enc_uint16le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint16le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint16le(uint16_t s, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 16 bit integer in little endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 2.
	<BR>
<P>
</P>
<A name="enc_uint32le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint32le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint32le(uint32_t i, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 32 bit integer in little endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 4.
	<BR>
<P>
</P>
<A name="enc_uint64le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_uint64le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_uint64le(uint64_t l, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 64 bit integer in little endian order into the memory at <tt>dst</tt> and return the number of bytes written which is always 8.
	<BR>
<P>
</P>
<A name="dec_uint16be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint16be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint16_t dec_uint16be(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 16 bit integer decoded in big endian byte order from 2 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_uint32be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint32be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint32_t dec_uint32be(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 32 bit integer decoded in big endian byte order from 4 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_uint64be"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint64be</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint64_t dec_uint64be(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 64 bit integer decoded in big endian byte order from 8 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_uint16le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint16le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint16_t dec_uint16le(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 16 bit integer decoded in little endian byte order from 2 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_uint32le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint32le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint32_t dec_uint32le(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 32 bit integer decoded in little endian byte order from 4 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_uint64le"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_uint64le</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  uint64_t dec_uint64le(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 64 bit integer decoded in little endian byte order from 8 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<H3>1.3. Time functions</H3>
These functions may be used to encode a wide variety of low-resolution time encodings.
<A name="enc_time"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_time</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_time(const time_t *timep, unsigned char *dst, int enc);<BR>
</PRE>
<B>Description</B>
<BR>
Encode the <TT>time_t</TT> object pointed to by <tt>timep</tt> into the memory at <tt>dst</tt> encoded in <tt>enc</tt> format. The following constants are valid <tt>enc</tt> parameters.
<PRE>

  Identifier            Units        Epoch Bits Endianess Use case
  ----------------------------------------------------------------
  TIME_1970_SEC_32BE    Seconds      1970  32   big       time_t
  TIME_1970_SEC_32LE    Seconds      1970  32   little    time_t
  TIME_1904_SEC_32BE    Seconds      1904  32   big       MS
  TIME_1904_SEC_32LE    Seconds      1904  32   little    MS
  TIME_1601_NANOS_64BE  Nanoseconds  1601  64   big       MS
  TIME_1601_NANOS_64LE  Nanoseconds  1601  64   little    MS
  TIME_1970_MILLIS_64BE Milliseconds 1970  64   big       Java
  TIME_1970_MILLIS_64LE Milliseconds 1970  64   little    Java
  </PRE>
	<P>
</P>
<A name="dec_time"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_time</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  time_t dec_time(const unsigned char *src, int enc);<BR>
</PRE>
<B>Description</B>
<BR>
Decode a return a <TT>time_t</TT> object encoded as <tt>enc</tt> in <tt>src</tt>. The constants listed in the <tt>enc_time</tt> description are valid <tt>enc</tt> parameters for this function as well.
	<BR>
<P>
</P>
<H3>1.4. Floating point numbers</H3>
<A name="enc_floatle"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_floatle</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_floatle(const float f, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 32 bit real number <tt>f</tt> into <tt>dst</tt> in little endian IEEE754 format and return the number of bytes encoded which is always 4.
	<BR>
<P>
</P>
<A name="enc_doublele"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_doublele</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_doublele(const double d, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 64 bit real number <tt>d</tt> into <tt>dst</tt> in little endian IEEE754 format and return the number of bytes encoded which is always 8.
	<BR>
<P>
</P>
<A name="enc_floatbe"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_floatbe</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_floatbe(const float f, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 32 bit real number <tt>f</tt> into <tt>dst</tt> in big endian IEEE754 format and return the number of bytes encoded which is always 4.
	<BR>
<P>
</P>
<A name="enc_doublebe"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_doublebe</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t enc_doublebe(const double d, unsigned char *dst);<BR>
</PRE>
<B>Description</B>
<BR>
Encode a 64 bit real number <tt>d</tt> into <tt>dst</tt> in big endian IEEE754 format and return the number of bytes encoded which is always 8.
	<BR>
<P>
</P>
<A name="dec_floatle"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_floatle</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  float dec_floatle(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 32 bit real number decoded in little endian IEEE754 format from 4 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_doublele"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_doublele</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  double dec_doublele(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 64 bit real number decoded in little endian IEEE754 format from 8 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_floatbe"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_floatbe</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  float dec_floatbe(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 32 bit real number decoded in big endian IEEE754 format from 4 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<A name="dec_doublebe"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_doublebe</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  double dec_doublebe(const unsigned char *src);<BR>
</PRE>
<B>Description</B>
<BR>
Return a 64 bit real number decoded in big endian IEEE754 format from 4 bytes of <tt>src</tt> memory.
	<BR>
<P>
</P>
<H3>1.5. Sting functions</H3>
<A name="enc_mbsncpy"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_mbsncpy</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  int enc_mbsncpy(const char *src,
           size_t sn,
           char **dst,
           size_t dn,
           int cn,
           const char *tocode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>enc_mbsncpy</TT> function encodes the multi-byte string at <tt>src</tt> into <tt>dst</tt>  using the <tt>tocode</tt> encoding identifier. The <tt>tocode</tt> parameter can be one of the standard encoding identifiers such as "UTF-8", "KOI8-R", "ISO-8859-2", etc. See the libiconv documentation for a complete list:
<p>
</p>
<a href="http://www.gnu.org/software/libiconv/">http://www.gnu.org/software/libiconv/</a>
<p>
</p>
 Specifically the <TT>enc_mbsncpy</TT> function;
<ul>
<li>does not read more than <tt>sn</tt> bytes of <tt>src</tt>,</li>
<li>does not write to more than <tt>dn</tt> bytes of <tt>dst</tt>,</li>
<li>does not convert more than <tt>cn</tt> characters,</li>
<li>does not convert characters after a '\0' encountered in <tt>src</tt>,</li>
<li>advances <tt>dst</tt> by the number of bytes encoded into <tt>dst</tt>
</li>
<li>and returns the number of characters converted</li>
</ul>
	<BR>
<P>
</P>
<A name="enc_mbscpy"></A>
<P>
</P>
<B CLASS="tfc">The <TT>enc_mbscpy</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  int enc_mbscpy(const char *src, char **dst, const char *tocode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>enc_mbscpy</TT> function encodes the multi-byte string at <tt>src</tt> into <tt>dst</tt>  using the <tt>tocode</tt> encoding identifier.
The conversion stops when a '\0' character is encountered in <tt>src</tt>.
This function is equivalent to <tt>enc_mbsncpy(src, INT_MAX, dst, INT_MAX, INT_MAX, tocode)</tt>. See <tt>enc_mbsncpy</tt> for details.
	<BR>
<P>
</P>
<A name="dec_mbsncpy"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_mbsncpy</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t dec_mbsncpy(char **src,
           size_t sn,
           char *dst,
           size_t dn,
           int cn,
           const char *fromcode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>dec_mbsncpy</TT> function decodes the string at <tt>src</tt> encoded as <tt>fromcode</tt> to the memory at <tt>dst</tt> as a locale dependent string (possibly UTF-8). The <tt>fromcode</tt> parameter can be one of the standard encoding identifiers such as "UTF-8", "KOI8-R", "ISO-8859-2", etc. See the libiconv documentation for a complete list:
<p>
</p>
<a href="http://www.gnu.org/software/libiconv/">http://www.gnu.org/software/libiconv/</a>
<p>
</p>
More specifically the <TT>dec_mbsncpy</TT> function;
<ul>
<li>does not read more than <tt>sn</tt> bytes of <tt>src</tt>,</li>
<li>does not write to more than <tt>dn</tt> bytes of <tt>dst</tt>,</li>
<li>does not convert more than <tt>cn</tt> characters,</li>
<li>does not convert characters after a '\0' encountered in <tt>src</tt>,</li>
<li>advances <tt>src</tt> by the number of bytes decoded,</li>
<li>and returns the number of bytes written to <tt>dst</tt> unless a '\0' terminator is not encountered in <tt>src</tt> in which case one is artifically written to <tt>dst</tt> but not counted in the return value.</li>
</ul>
Additionally, if <tt>dst</tt> is NULL this function
<ul>
<li>does not write to <tt>dst</tt>,</li>
<li>does not advance the <tt>src</tt> pointer,</li>
<li>and returns the exact number of bytes required to encode a multi-byte string had <tt>dst</tt> not been NULL (i.e. for malloc). This includes the '\0' terminator regardless of wheather one was encountered in <tt>src</tt>.</li>
</ul>
	<BR>
<P>
</P>
<A name="dec_mbscpy"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_mbscpy</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  size_t dec_mbscpy(char **src, char *dst, const char *fromcode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>dec_mbscpy</TT> function decodes the string at <tt>src</tt> encoded as <tt>fromcode</tt> to the memory at <tt>dst</tt> as a locale dependent string (possibly UTF-8).
The conversion stops when the character '\0' is encountered in <tt>src</tt>.
This function is equivalent to <tt>dec_mbsncpy(src, INT_MAX, dst, INT_MAX, INT_MAX, fromcode);</tt>. See <tt>dec_mbscpy</tt> for details.
	<BR>
<P>
</P>
<A name="dec_mbsndup"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_mbsndup</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  char *dec_mbsndup(char **src,
           size_t sn,
           size_t dn,
           int wn,
           const char *fromcode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>dec_mbsndup</TT> function decodes the string at <tt>src</tt> encoded as <tt>fromcode</tt> and returns a locale dependent string (possibly UTF-8) stored in memory allocated with <TT>malloc</TT>(3). This memory should be freed with <TT>free</TT>(3) when it will no longer be referenced. This function just calls <tt>dec_mbsncpy(src, sn, NULL, dn, wn, fromcode)</tt>, allocates the precise amount of memory, encodes the string in it with <tt>dec_mbsncpy(src, sn, dst, dn, wn, fromcode)</tt>, and returns the new string.
	<BR>
<P>
</P>
<A name="dec_mbsdup"></A>
<P>
</P>
<B CLASS="tfc">The <TT>dec_mbsdup</TT> function</B>
<BR>
<B>Synopsis</B>
<PRE>
<BR>  #include &lt;encdec.h&gt;
  char *dec_mbsdup(char **src, const char *fromcode);<BR>
</PRE>
<B>Description</B>
<BR>
The <TT>dec_mbsdup</TT> function decodes the string at <tt>src</tt> encoded as <tt>fromcode</tt> and returns a locale dependent string (possibly UTF-8) stored in memory allocated with <TT>malloc</TT>(3). This memory should be freed with <TT>free</TT>(3) when it will no longer be referenced. This function is equivalent to <tt>dec_mbsndup(src, -1, -1, -1, fromcode)</tt>. See <tt>dec_mbsndup</tt> for details.
	<BR>
<P>
</P>
<HR NOSHADE>
	Copyright 2002 Michael B. Allen &lt;mballen@erols.com&gt;
</BODY>
</HTML>
